package SyntaxAnalyzer;

import java.io.PrintWriter;

/**
 * Recursive top-down parser. Gets input from a Jack Tokenizer and emits its
 * parsed structure into an output file/stream.
 * Output is generated by a series of compilexxx() routines, one for every syntactic element xxx
 * of the Jack grammar. Emits a structured printout of the code, wrapped in XML tags.
 */

public class CompilationEngine {

    private JackTokenizer tokenizer; // input tokens
    private PrintWriter outputWriter; // output file

    // Creates a new compilation engine with the given input and output
    // Next routine called must be compileClass()
    public CompilationEngine(JackTokenizer tokenizer, PrintWriter outputWriter) {
        this.tokenizer = tokenizer;
        this.outputWriter = outputWriter;
    }

    // Compiles a complete class
    public void compileClass() {

        tokenizer.advance();

        // File must start with "class"
        requireToken(NonTerminals.CLASS);
        outputWriter.println("<class>");

        printTerminalAndAdvance();

        // "class" keyword must be followed by class name
        requireToken(NonTerminals.CLASS_NAME);
        printTerminalAndAdvance();

        // Class name must be followed by "{" symbol
        requireToken(JackTokenizer.TokenType.SYMBOL, "{");
        printTerminalAndAdvance();

        // Print any class var declarations
        while (tokenMatches(NonTerminals.CLASS_VAR_DEC)){
            compileClassVarDec();
        }

        // Print any subroutine declarations
        while (tokenMatches(NonTerminals.SUBROUTINE_DEC)){
            compileSubroutine();
        }

        requireToken(JackTokenizer.TokenType.SYMBOL, "}");
        printTerminal(); // print enclosing "}" for class

        outputWriter.println("</class>");
    }

    // Compiles a static declaration of a field declaration
    public void compileClassVarDec() {
        requireToken(NonTerminals.CLASS_VAR_DEC);
        outputWriter.println("<classVarDec>");

        // Print static or field
        printTerminalAndAdvance();

        // Print the type of var
        requireToken(NonTerminals.TYPE);
        printTerminalAndAdvance();

        // Print the name of var
        requireToken(NonTerminals.VAR_NAME);
        printTerminalAndAdvance();

        // Print comma-separated vars
        while (tokenizer.symbol() == ',') {
            printTerminalAndAdvance();
            requireToken(NonTerminals.VAR_NAME); // comma must be followed by varName
            printTerminalAndAdvance();
        }

        requireToken(JackTokenizer.TokenType.SYMBOL, ";");
        printTerminalAndAdvance(); // print ";" marking end of varDec
        outputWriter.println("</classVarDec>");
    }

    // Compiles a complete method, function, or constructor
    public void compileSubroutine() {
        requireToken(NonTerminals.SUBROUTINE_DEC);
        outputWriter.println("<subroutineDec>");
        printTerminalAndAdvance(); // print "constructor"/"function"/"method"

        // print return type
        requireToken(NonTerminals.TYPE, "void");
        printTerminalAndAdvance();

        // print name of subroutine
        requireToken(NonTerminals.SUBROUTINE_NAME);
        printTerminalAndAdvance();

        compileParameterList();

        // print subroutine body
        requireToken(JackTokenizer.TokenType.SYMBOL, "{");
        outputWriter.println("<subroutineBody>");
        printTerminalAndAdvance();

        // print any var declarations
        while (tokenMatches(NonTerminals.VAR_DEC)) {
            compileVarDec();
        }

        compileStatements();

        requireToken(JackTokenizer.TokenType.SYMBOL, "}");
        printTerminalAndAdvance(); // print enclosing "}"
        outputWriter.println("</subroutineBody>");

        outputWriter.println("</subroutineDec>");
    }

    // Compiles a (possibly empty) parameter list, not including the enclosing "()"
    public void compileParameterList() {
        requireToken(JackTokenizer.TokenType.SYMBOL, "("); // print opening parenthesis
        printTerminalAndAdvance();
        outputWriter.println("<parameterList>");

        // Print any parameters
        while (tokenMatches(NonTerminals.TYPE)) {
            printTerminalAndAdvance(); // print var type
            requireToken(NonTerminals.VAR_NAME);
            printTerminalAndAdvance(); // print var name
            if (tokenMatches(JackTokenizer.TokenType.SYMBOL, ",")) {
                printTerminalAndAdvance(); // print comma
                requireToken(NonTerminals.TYPE);
            } else {
                break;
            }
        }

        outputWriter.println("</parameterList>");
        requireToken(JackTokenizer.TokenType.SYMBOL, ")");
        printTerminalAndAdvance(); // print closing parenthesis for parameter list
    }

    // Compiles a var declaration
    public void compileVarDec() {
        outputWriter.println("<varDec>");

        printTerminalAndAdvance(); // print "var"
        requireToken(NonTerminals.TYPE);
        printTerminalAndAdvance(); // print var type
        requireToken(NonTerminals.VAR_NAME);
        while (true) {
            printTerminalAndAdvance(); // print var name
            if (tokenMatches(JackTokenizer.TokenType.SYMBOL, ",")) {
                printTerminalAndAdvance();
                requireToken(NonTerminals.VAR_NAME);
            } else {
                requireToken(JackTokenizer.TokenType.SYMBOL, ";");
                printTerminalAndAdvance(); // print ending semicolon
                break;
            }
        }

        outputWriter.println("</varDec>");
    }

    // Compiles a sequence of statements, not including the enclosing "{}"
    public void compileStatements() {
        requireToken(NonTerminals.STATEMENT);
        outputWriter.println("<statements>");

        // iterate while there are still statements to process
        while(tokenMatches(NonTerminals.STATEMENT)) {

            // determine what kind of statement it is
            if (tokenMatches(JackTokenizer.TokenType.KEYWORD, "let")) {
                compileLet();
            } else if (tokenMatches(JackTokenizer.TokenType.KEYWORD, "if")) {
                compileIf();
            } else if (tokenMatches(JackTokenizer.TokenType.KEYWORD, "while")) {
                compileWhile();
            } else if (tokenMatches(JackTokenizer.TokenType.KEYWORD, "do")) {
                compileDo();
            } else {
                compileReturn();
            }
        }

        outputWriter.println("</statements>");
    }

    // Compiles a do statement
    public void compileDo() {
        outputWriter.println("<doStatement>");

        printTerminalAndAdvance(); // print "do"
        requireToken(NonTerminals.SUBROUTINE_CALL);

        // compile subroutine
        compileSubroutineCall();

        requireToken(JackTokenizer.TokenType.SYMBOL, ";");
        printTerminalAndAdvance(); // print ";" marking end of stmt

        outputWriter.println("</doStatement>");
    }

    // Compiles a let statement
    public void compileLet() {
        outputWriter.println("<letStatement>");

        printTerminalAndAdvance(); // print "let"
        requireToken(NonTerminals.VAR_NAME);
        printTerminalAndAdvance(); // print var name
        if (tokenMatches(JackTokenizer.TokenType.SYMBOL, "[")) { // check for square brackets for arrays
            printTerminalAndAdvance();
            compileExpression();
            requireToken(JackTokenizer.TokenType.SYMBOL, "]");
            printTerminalAndAdvance(); // print closing square bracket
        }
        requireToken(JackTokenizer.TokenType.SYMBOL, "=");
        printTerminalAndAdvance(); // print equal sign

        compileExpression();

        requireToken(JackTokenizer.TokenType.SYMBOL, ";");
        printTerminalAndAdvance(); // print ending semicolon

        outputWriter.println("</letStatement>");
    }

    // compiles a while statement
    public void compileWhile() {
        outputWriter.println("<whileStatement>");

        printTerminalAndAdvance(); // print "while"

        requireToken(JackTokenizer.TokenType.SYMBOL, "(");
        printTerminalAndAdvance(); // print opening parenthesis

        requireToken(NonTerminals.EXPRESSION);
        compileExpression(); // compile exp that's the condition of the while

        requireToken(JackTokenizer.TokenType.SYMBOL, ")");
        printTerminalAndAdvance(); // print cosing parenthesis

        requireToken(JackTokenizer.TokenType.SYMBOL, "{");
        printTerminalAndAdvance(); // print opening curly brace

        // compile statements in body of while
        requireToken(NonTerminals.STATEMENT);
        compileStatements();

        requireToken(JackTokenizer.TokenType.SYMBOL, "}");
        printTerminalAndAdvance(); // print "}" marking end of stmt

        outputWriter.println("</whileStatement>");
    }

    // Compiles a return statement
    public void compileReturn() {
        outputWriter.println("<returnStatement>");

        printTerminalAndAdvance(); // print "return"

        // print any expressions
        while (tokenMatches(NonTerminals.EXPRESSION)) {
            compileExpression();
        }

        requireToken(JackTokenizer.TokenType.SYMBOL, ";");
        printTerminalAndAdvance(); // print ";" marking end of stmt

        outputWriter.println("</returnStatement>");
    }

    // Compiles an if statement, possibly with a trailing else clause
    public void compileIf() {
        outputWriter.println("<ifStatement>");

        printTerminalAndAdvance(); // print "if"

        requireToken(JackTokenizer.TokenType.SYMBOL, "(");
        printTerminalAndAdvance(); // print opening parenthesis

        // compile exp that is the condition of the if
        requireToken(NonTerminals.EXPRESSION);
        compileExpression();

        requireToken(JackTokenizer.TokenType.SYMBOL, ")");
        printTerminalAndAdvance(); // print closing parenthesis

        requireToken(JackTokenizer.TokenType.SYMBOL, "{");
        printTerminalAndAdvance(); // print opening curly brace

        // compile statement(s) in body of if
        requireToken(NonTerminals.STATEMENT);
        compileStatements();

        requireToken(JackTokenizer.TokenType.SYMBOL, "}");
        printTerminalAndAdvance(); // print closing curly brace

        // compile else clause if needed
        if (tokenMatches(JackTokenizer.TokenType.KEYWORD, "else")) {
            printTerminalAndAdvance(); // print else
            requireToken(JackTokenizer.TokenType.SYMBOL, "{");
            printTerminalAndAdvance(); // print opening curly brace
            compileStatements();
            requireToken(JackTokenizer.TokenType.SYMBOL, "}");
            printTerminalAndAdvance(); // print closing curly brace
        }

        outputWriter.println("</ifStatement>");
    }

    // Compiles a subroutine call
    public void compileSubroutineCall() {
        boolean isSubroutine; // call starts either with subroutineName or className|varName

        printTerminalAndAdvance(); // print subRoutineName or className

        if (tokenMatches(JackTokenizer.TokenType.SYMBOL, "(")) {
            isSubroutine = true;
        } else if (tokenMatches(JackTokenizer.TokenType.SYMBOL, ".")) {
            isSubroutine = false;
        } else {
            throw new IllegalArgumentException("Expected \"(\" or \".\" instead of " + tokenizer.getToken());
        }

        printTerminalAndAdvance(); // print either "(" or "."

        if (isSubroutine) {
            compileExpressionList();
        } else {
            printTerminalAndAdvance(); // print subroutineName
            requireToken(JackTokenizer.TokenType.SYMBOL, "(");
            printTerminalAndAdvance();
            compileExpressionList();
        }

        requireToken(JackTokenizer.TokenType.SYMBOL, ")");
        printTerminalAndAdvance();
    }

    // Compiles an expression
    public void compileExpression() {
        outputWriter.println("<expression>");

        requireToken(NonTerminals.TERM);
        compileTerm(); // print first term in expression

        // if expr is of form "term op term", compile "op term"
        while (tokenMatches(NonTerminals.OP)) {
            printTerminalAndAdvance(); // print the symbol for the op
            requireToken(NonTerminals.TERM); // op must be followed by another term
            compileTerm();
        }

        outputWriter.println("</expression>");
    }

    // Compiles a term
    public void compileTerm() {
        outputWriter.println("<term>");

        // If term is just a single token
        if (tokenizer.tokenType() == JackTokenizer.TokenType.INT_CONST ||
                tokenizer.tokenType() == JackTokenizer.TokenType.STRING_CONST ||
                tokenMatches(NonTerminals.KEYWORD_CONSTANT)) {
            printTerminalAndAdvance();
        } else if (tokenMatches(NonTerminals.UNARY_OP)) {
            // unary op followed by term
            printTerminalAndAdvance();
            compileTerm();
        } else if (tokenMatches(JackTokenizer.TokenType.SYMBOL, "(")) {
            // expression within parentheses
            printTerminalAndAdvance();
            compileExpression();
            requireToken(JackTokenizer.TokenType.SYMBOL, ")");
            printTerminalAndAdvance();
        } else if (tokenizer.tokenType() == JackTokenizer.TokenType.IDENTIFIER) {
            // distinguish between var, arr entry, and subroutine call
            tokenizer.advance();
            char sym = tokenizer.symbol();
            tokenizer.rewind();
            if (sym == '[') { // array entry
                printTerminalAndAdvance(); // print varName
                printTerminalAndAdvance(); // print "["
                compileExpression();
                requireToken(JackTokenizer.TokenType.SYMBOL, "]");
                printTerminalAndAdvance(); // print "]"
            } else if (sym == '(' || sym == '.') { // subroutine call
                compileSubroutineCall();
            } else {
                printTerminalAndAdvance(); // varName
            }
        }
        outputWriter.println("</term>");
    }

    // Compiles a (possibly empty) comma-separated list of expressions
    public void compileExpressionList() {
        outputWriter.println("<expressionList>");

        // Print any expressions in this list
        while (tokenMatches(NonTerminals.EXPRESSION)) {
            compileExpression();
            if (tokenMatches(JackTokenizer.TokenType.SYMBOL, ",")) {
                printTerminalAndAdvance(); // print comma separating expressions
                requireToken(NonTerminals.EXPRESSION); // comma must be followed by expr
            } else {
                break;
            }
        }

        outputWriter.println("</expressionList>");
    }

    // Checks that token fulfills the expected construct and throws an error otherwise
    private void requireToken(JackTokenizer.TokenType expectedType, String value) {
        if (tokenizer.tokenType() != expectedType || !tokenizer.getToken().equals(value)) {
            throw new IllegalArgumentException("Expected token of type " + expectedType +
                    " and value " + value + " instead of the following: " + tokenizer.getToken());
        }
    }

    private void requireToken(NonTerminals category) {
        if (!tokenMatches(category)) {
            throw new IllegalArgumentException("Expected token of type " + category
                    + " instead of the following: " + tokenizer.getToken());
        }
    }

    private void requireToken(NonTerminals category, String value1) {
        if (!tokenMatches(category) && !tokenizer.getToken().matches(value1)) {
            throw new IllegalArgumentException("Expected token of type " + category
                    + " or form " + value1 + " instead of the following: " + tokenizer.getToken());
        }
    }

    // Checks whether token is of the specified construct
    // (Checks could be stronger; only validates first token of the construct)
    private boolean tokenMatches(NonTerminals category) {
        switch (category) {
            case CLASS:
                return validateToken(JackTokenizer.TokenType.KEYWORD, "class");
            case CLASS_VAR_DEC:
                return (validateToken(JackTokenizer.TokenType.KEYWORD, "static") ||
                        validateToken(JackTokenizer.TokenType.KEYWORD, "field"));
            case SUBROUTINE_DEC:
                return (validateToken(JackTokenizer.TokenType.KEYWORD, "constructor") ||
                        validateToken(JackTokenizer.TokenType.KEYWORD, "function") ||
                        validateToken(JackTokenizer.TokenType.KEYWORD, "method"));
            case TYPE:
                return (validateToken(JackTokenizer.TokenType.KEYWORD, "int") ||
                        validateToken(JackTokenizer.TokenType.KEYWORD, "char") ||
                        validateToken(JackTokenizer.TokenType.KEYWORD, "boolean") ||
                        tokenMatches(NonTerminals.CLASS_NAME));
            case VAR_DEC:
                return (validateToken(JackTokenizer.TokenType.KEYWORD, "var"));
            case CLASS_NAME:
            case VAR_NAME:
            case SUBROUTINE_NAME:
                return (validateToken(JackTokenizer.TokenType.IDENTIFIER));
            case SUBROUTINE_CALL:
                return validateToken(JackTokenizer.TokenType.IDENTIFIER);
            case STATEMENT:
                return(validateToken(JackTokenizer.TokenType.KEYWORD, "let") ||
                        validateToken(JackTokenizer.TokenType.KEYWORD, "if") ||
                        validateToken(JackTokenizer.TokenType.KEYWORD, "while") ||
                        validateToken(JackTokenizer.TokenType.KEYWORD, "do") ||
                        validateToken(JackTokenizer.TokenType.KEYWORD, "return"));
            case EXPRESSION:
                return tokenMatches(NonTerminals.TERM);
            case TERM:
                return(validateToken(JackTokenizer.TokenType.INT_CONST) ||
                        validateToken(JackTokenizer.TokenType.STRING_CONST) ||
                        tokenMatches(NonTerminals.KEYWORD_CONSTANT) ||
                        tokenMatches(NonTerminals.VAR_NAME) ||
                        tokenMatches(NonTerminals.SUBROUTINE_CALL) ||
                        tokenMatches(JackTokenizer.TokenType.SYMBOL, "(") ||
                        tokenMatches(NonTerminals.UNARY_OP));
            case UNARY_OP:
                return (tokenMatches(JackTokenizer.TokenType.SYMBOL, "-") ||
                        tokenMatches(JackTokenizer.TokenType.SYMBOL, "~"));
            case OP:
                return (tokenMatches(JackTokenizer.TokenType.SYMBOL, "+") ||
                        tokenMatches(JackTokenizer.TokenType.SYMBOL, "-") ||
                        tokenMatches(JackTokenizer.TokenType.SYMBOL, "*") ||
                        tokenMatches(JackTokenizer.TokenType.SYMBOL, "/") ||
                        tokenMatches(JackTokenizer.TokenType.SYMBOL, "&") ||
                        tokenMatches(JackTokenizer.TokenType.SYMBOL, "|") ||
                        tokenMatches(JackTokenizer.TokenType.SYMBOL, "<") ||
                        tokenMatches(JackTokenizer.TokenType.SYMBOL, ">") ||
                        tokenMatches(JackTokenizer.TokenType.SYMBOL, "="));
            case KEYWORD_CONSTANT:
                return (tokenMatches(JackTokenizer.TokenType.KEYWORD, "true") ||
                        tokenMatches(JackTokenizer.TokenType.KEYWORD, "false") ||
                        tokenMatches(JackTokenizer.TokenType.KEYWORD, "null") ||
                        tokenMatches(JackTokenizer.TokenType.KEYWORD, "this"));
            default:
                return false;
        }
    }

    private boolean tokenMatches(JackTokenizer.TokenType type, String value) {
        return (tokenizer.tokenType() == type && tokenizer.getToken().equals(value));
    }

    // Checks if token matches a certain type and value and returns boolean
    private boolean validateToken(JackTokenizer.TokenType type, String value) {
        return (tokenizer.tokenType() == type && tokenizer.getToken().equals(value));
    }

    private boolean validateToken(JackTokenizer.TokenType type) {
        return (tokenizer.tokenType() == type);
    }

    // Enumerates the various types of non-terminals
    private static enum NonTerminals {
        CLASS, CLASS_VAR_DEC, TYPE, SUBROUTINE_DEC, PARAMETER_LIST, SUBROUTINE_BODY,
        VAR_DEC, CLASS_NAME, SUBROUTINE_NAME, VAR_NAME, STATEMENT, SUBROUTINE_CALL,
        EXPRESSION, TERM, OP, UNARY_OP, KEYWORD_CONSTANT
    }

    // Prints terminal value and its corresponding type, then advances tokenizer
    private void printTerminalAndAdvance() {
        printTerminal();

        // Throw an error if unable to advance
        if (!tokenizer.hasMoreTokens()) {
            throw new IllegalStateException("No more tokens after " + tokenizer.getToken());
        }

        tokenizer.advance();
    }

    private void printTerminal() {
        switch (tokenizer.tokenType()) {
            case IDENTIFIER:
                outputWriter.println("<identifier> " + tokenizer.identifier() + " </identifier>");
                break;
            case KEYWORD:
                outputWriter.println("<keyword> " + tokenizer.keyWord() + " </keyword>");
                break;
            case SYMBOL:
                char sym = tokenizer.symbol();
                String printedValue = null;
                switch (sym) { // swap out xml-reserved chars
                    case '<':
                        printedValue = "&lt;";
                        break;
                    case '>':
                        printedValue = "&gt;";
                        break;
                    case '&':
                        printedValue = "&amp;";
                        break;
                    case '"':
                        printedValue = "&quot;";
                        break;
                    default:
                        printedValue = String.valueOf(sym);
                        break;
                }
                outputWriter.println("<symbol> " + printedValue + " </symbol>");
                break;
            case STRING_CONST:
                outputWriter.println("<stringConstant> " + tokenizer.stringVal() + " </stringConstant>");
                break;
            case INT_CONST:
                outputWriter.println("<integerConstant> " + tokenizer.intVal() + " </integerConstant>");
                break;

        }
    }
}
